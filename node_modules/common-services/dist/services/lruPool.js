import { autoProvider, name } from 'knifecycle';
import { noop } from '../utils/utils.js';
import { printStackTrace } from 'yerror';
/* Architecture Note #1.10: LRU Pool

The `lruPool` service allows to maintain a pool of
  resources. It is meant to be used with resources
  like file descriptors that are limited in most
  OSes but are pointing to completely different
  kind of resources (files paths varies).
*/
export default name('lruPool', autoProvider(initLRUPool));
/**
 * Instantiate the LRU Pool service
 * @name initRandom
 * @function
 * @param  {Object}   services           The services to inject
 * @param  {Object}   [services.log = noop]     A logging function
 * @return {Promise<Function>}           A promise of the LRUPool service
 * @example
 * import {
 *   DEFAULT_LOGGER,
 *   initLog,
 *   initLRUPool
 * } from 'common-services';
 *
 * const log = await initLog({
 *   logger: DEFAULT_LOGGER,
 * });
 *
 * const random = await initLRUPool({
 *   MAX_POOL_SIZE: 50,
 *   poolManager: {
 *     // ...
 *   },
 *   log,
 * });
 */
export async function initLRUPool({ MAX_POOL_SIZE, POOL_TTL, poolManager, delay, log = noop, }) {
    log('warning', `✅ - Initializing a LRU pool service.`);
    const poolMap = new Map();
    const delayMap = new Map();
    const poolLRUQueue = [];
    const service = {
        async use(config) {
            if (poolLRUQueue.length >= MAX_POOL_SIZE) {
                const key = poolLRUQueue.shift();
                const item = poolMap.get(key);
                log('debug', `🧹 - Pool is full, releasing an item (${key}).`);
                await poolManager.release(item);
                poolMap.delete(key);
                if (delayMap.has(key)) {
                    delay.clear(delayMap.get(key));
                    delayMap.delete(key);
                }
            }
            const key = JSON.stringify(config);
            let item;
            if (poolMap.has(key)) {
                item = poolMap.get(key);
                poolLRUQueue.splice(poolLRUQueue.indexOf(key), 1);
                log('debug', `♻️ - Reusing an item from the pool (${key}).`);
            }
            else {
                log('debug', `➕ - Creating an item from the pool.`);
                item = await poolManager.create(config);
                poolMap.set(key, item);
                if (POOL_TTL) {
                    const delayPromise = delay.create(POOL_TTL);
                    delayMap.set(key, delayPromise);
                    delayPromise
                        .then(() => {
                        if (poolMap.has(key)) {
                            poolLRUQueue.splice(poolLRUQueue.indexOf(key), 1);
                            poolMap.delete(key);
                            delayMap.delete(key);
                            log('debug', `🧹 - Pool is releasing an item by ttl (${key}).`);
                            return poolManager.release(item);
                        }
                    })
                        .catch((err) => {
                        if (err.code === 'E_DELAY_CLEARED') {
                            return;
                        }
                        log('error', `🛑 - Delayed release error (${key}).`);
                        log('error-stack', printStackTrace(err));
                    });
                }
            }
            poolLRUQueue.push(key);
            return item;
        },
    };
    const dispose = async () => {
        for (const item of poolMap.values()) {
            await poolManager.release(item);
        }
        poolMap.clear();
        for (const item of delayMap.values()) {
            await delay.clear(item);
        }
        delayMap.clear();
        poolLRUQueue.length = 0;
    };
    return { service, dispose };
}
//# sourceMappingURL=lruPool.js.map