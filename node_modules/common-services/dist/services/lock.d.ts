import type { LogService } from './log.js';
import type { DelayService } from './delay.js';
interface Lock {
    releasePromise: Promise<void>;
    release: () => void;
}
export type LockServiceConfig<K> = {
    LOCKS_MAP?: Map<K, Lock[]>;
    LOCK_TIMEOUT?: number;
};
type LockServiceDependencies<K> = LockServiceConfig<K> & {
    log?: LogService;
    delay: DelayService;
};
export interface LockService<K> {
    take: (key: K, timeout?: number) => Promise<void>;
    release: (key: K) => Promise<void>;
}
declare const _default: typeof initLock;
export default _default;
/**
 * Instantiate the lock service
 * @name initLock
 * @function
 * @param  {Object}     services
 * The services to inject
 * @param  {Map}   [services.LOCKS_MAP]
 * A map to store le current locks (optional)
 * @param  {Number}   [services.LOCK_TIMEOUT=Infitiny]
 * The timeout in milliseconds for the lock to
 *  be released.
 * @param  {Function}   [services.log]
 * A logging function
 * @param  {Object}   [services.delay]
 * A delay service like the `common-services` one
 * @return {Promise<Object>}
 * A promise of the lock service
 * @example
 * import {
 *   DEFAULT_LOGGER,
 *   initLog,
 *   initDelay,
 *   initLock
 * } from 'common-services';
 * import ms from 'ms';
 *
 * const log = await initLog({
 *   logger: DEFAULT_LOGGER
 * });
 * const delay = await initDelay({ log });
 * const lock = await initLock({
 *   LOCK_TIMEOUT: ms('5s'),
 *   delay,
 *   log,
 * });
 *
 *
 * run();
 *
 * async function run() {
 *   // The following async jobs are done sequentially
 *   // if they have the same `resourceKey` value
 *   await Promise.all(asynTasks.map(async (asyncTask) => {
 *     await lock.take(asyncTask.resourceKey);
 *
 *     await myAsyncStuff1(asyncTask);
 *     await myAsyncStuff2(asyncTask);
 *     await myAsyncStuff3(asyncTask);
 *
 *    lock.release(asyncTask.resourceKey);
 *   });
 * }
 */
declare function initLock<T>({ LOCKS_MAP, LOCK_TIMEOUT, delay, log, }: LockServiceDependencies<T>): Promise<LockService<T>>;
